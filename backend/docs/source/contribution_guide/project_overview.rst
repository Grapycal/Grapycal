Project Overview
=========================

Grapycal is still in its early stage. Any contribution is welcome. Currently, most of our efforts are on the backend (the core of Grapycal) and extensions (nodes with various functionalities), but it's also helpful to improve the frontend and the documentation.

To discuss, feel free to open an issue or join the `Discord server <https://discord.gg/adNQcS42CT>`_.

Application Structure
----------------------

When you run Grapycal, you starts a ``GrapycalApp``. ``GrapycalApp`` creates two processes, the workspace process and the HTTP server. When a user opens the Grapycal webpage, the browser first loads the frontend resources from the HTTP server. Then it connects to the workspace process with websocket.


.. figure:: https://i.imgur.com/jBijCP5.png
    :width: 100%
    :align: center

    The heighest level view of Grapycal. 

After the websocket connection is established, ``GrapycalApp`` and the HTTP server is barely used. We will from now focus on the workspace process (backend code) and the browser (frontend code).

The backend runs two threads, the background (main) thread and the communication thread. The background thread runs a syncronous loop with a queue to run tasks generated by nodes. The communication thread runs an event loop to handle communication with the frontend. 

The backend maintians an "SObject tree" that stores every user-interactable objects. The frontend also maintains a "SObject tree" that is syncronized with the backend, so it can render the UI accordingly. The Editor, Nodes, Edges, Ports, Controls, etc. are all SObjects. Pretty much all communication between the backend and the frontend are done through calling the API of local SObjects, so the code of Grapycal itself is kept clean.


.. figure:: https://i.imgur.com/awy635Z.jpg
    :width: 100%
    :align: center

Let's see how it works in detail. In the example below, we have a ExecNode that evaluates the string "Hello" and output it. An edge links the output port of the ExecNode to the input port of a PrintNode. Then, these happens:

1. When the user double clicks the ExecNode, the DOM element fires a "dblclick" event. 

2. The event is handled by the Node class and the Node class calls ``this.emit('double_click')``, which is a method of SObject. That through websocket invokes its backend counterpart's ``on_double_click`` method. 

3. The backend ExecNode's ``double_click`` method pushes a task to the background thread's queue.

.. figure:: https://i.imgur.com/6e310JD.jpg
    :width: 100%
    :align: center

4. The task runs in the background thread. It pushes the ``"Hello"`` string through the edge, to the PrintNode. The PrintNode then sets its ``label`` attribute to ``"Hello"`` by calling ``self.label.set("Hello")``.

5. Setting an attribute is also a part SObject's API. ``self.label.set("Hello")`` invokes the frontend PrintNode's ``label.onSet()`` method through websocket. The ``onSet()`` method updates the DOM element accordingly. That's the complete list of steps caused by the user's double click.

.. figure:: https://i.imgur.com/6CFoRn3.jpg
    :width: 100%
    :align: center

Project Structure
-----------------

.. code-block:: text

    Grapycal
        backend
            docs
            src/grapycal
                core
                    workspace.py
                    ... (other core classes)
                sobjects
                    ...
                extension
                    ...
                utils 
                    ...
                webpage
                    ...
                __init__.py
                __main__.py
                app.py
            pyproject.toml
    
        frontend
            dist ... (frontend resources)
            src
                components 
                    ...
                sobjects 
                    ...
                inspector 
                    ...
                ui_utils 
                    ...
                app.ts
                ...
            package.json
    
        extensions
            grapycal_builtin
            grapycal_torch
            grapycal_ros
            ...

The Grapycal application consists of the backend (written in Python) and the frontend (written in Typescript).

/backend
^^^^^^^^^^^^^^^^^

The backend folder is the python package of Grapycal. When you run `grapycal`, a GrapycalApp (``src/grapycal/app.py``) starts and creates two processes, the workspace (``src/grapycal/core/workspace.py``) and the HTTP server. The folder ``src/grapycal/sobjects`` contains the definition of all SObjects. The folder ``src/grapycal/extension`` contains management code of extensions (but not the code of extensions themselves).

/frontend
^^^^^^^^^^^^^^^^^

The frontend use no framework. It's just a bunch of Typescript classes. The UI is implemented with HTML and CSS (welcome to re-structure them if you know frontend!). 

The frontend folder is a npm package. The entry point, ``app.ts``, creates a websocket connection to the backend and ask for the information about the SObject tree and the topics. The folder ``src/sobjects`` contains the definition of all SObjects. The folder ``src/components`` contains some frequently used functionalities, like Transform and EventDispatcher. The folder ``src/inspector`` contains the code of the inspector and the attribute editors in the inspector. 


More about SObjects and topics
--------------------------------

To elegantly implement state syncronization between the backend and the frontend, we use `ObjectSync library <https://github.com/eri24816/ObjectSync>`_ to wrap two layers of abstractions on top of websocket: `Topics` and `SObject` s (Syncronized Object).

A `topic` is **a piece of data** that is shared across the backend and the frontend. When either side changes a topic, the change is automatically broadcasted to the other side with websocket so the other side can update the topic accordingly and reflect to the change if necessary.

A `SObject` is **an object** that is shared across the backend and the frontend. Each `SObject` owns a specific set of `attributes`, implemented with `topics`, syncronized between the backend and the frontend.

.. figure:: https://i.imgur.com/8fWPdNC.png
    :height: 250px
    :align: center

    The concept of SObject and topic. `o1` and `o2` are SObjects. `t1` - `t5` are topics. `t1` and `t2` are attributes of `o1`. `t3`, `t4` and `t5` are attributes of `o2`.


ObjectSync's implementation details are not important. We just need to know that
ObjectSync automatically do the following for Grapycal:

#. When a SObject is created/deleted on the backend, a SObject with the same class is automatically created/deleted on the frontend. 
#. When some attributes of SObject on the backend changes, the change is broadcasted to all frontends and the SObject on the frontends are updated accordingly.
#. When the SObject on a frontend is chagned by user, a request of change is sent to the backend. The backend updates the SObject accordingly and broadcast the change to all frontends.

Many class in Grapycal inherits from SObject, such as `Node`, `Edge`, `Port`, etc.. In a workspace, they are organized in a tree structure:

.. code-block:: text

    root
    └───Workspace
        ├───Sidebar
        │   ├───AdditionNode
        │   │   └──...     
        │   ├───EvalNode
        │   │   └──... 
        │   └───PrintNode
        │   │   └──... 
        └───Editor
            ├───AdditionNode
            │   └──... 
            ├───EvalNode
            │   └──... 
            ├───PrintNode
            │   └──... 
            ├───EvalNode
            │   └──... 
            ├───Edge
            └───Edge

The `Sidebar` contains preview of all the nodes that can be added to the editor. The `Editor` contains all the nodes and edges been added to it.

In each node, there can be `ports` and `controls`. For example:

.. code-block:: text

    SomeTypeOfNode
    ├───Port
    ├───Port
    ├───TextControl
    └───ButtonControl

A `port` is a connection point for edges. A `control` is a UI element that allows user to interact with the node. `Ports` and `controls` can be added to a node in the building process of the node, or be added (or removed) dynamically as the node's runtime behavior. For example, the lambda node creates a port each time user adds a new input variable.


Definitions of SObjects are in ``backend/src/grapycal/sobjects`` and ``frontend/src/sobjects``.