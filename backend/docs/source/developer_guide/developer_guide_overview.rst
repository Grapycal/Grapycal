Developer Guide: Overview
=========================

Grapycal is still in its early stage. Any contribution is welcome. Currently, most of our efforts are on the backend (the core of Grapycal) and extensions (nodes with various functionalities), but it's also helpful to improve the frontend and the documentation.

In the `GitHub discussion <https://github.com/eri24816/Grapycal/discussions>`_ you can find features we are / about to working on. You can join the discussion and share your ideas. If you want to contribute, feel free to open a pull request. If you have any question, feel free to open an issue or join the `Discord server <https://discord.gg/adNQcS42CT>`_.




Project Structure
-----------------

.. code-block:: text

    Grapycal
        backend
            docs
            src/grapycal
                core
                    workspace.py
                    ... (other core classes)
                sobjects
                    ...
                extensions
                    ...
                utils 
                    ...
                webpage
                    ...
                __init__.py
                __main__.py
                app.py
            pyproject.toml
    
        frontend
            dist ... (frontend resources)
            src
                components 
                    ...
                sobjects 
                    ...
                inspector 
                    ...
                ui_utils 
                    ...
                app.ts
                ...
            package.json
    
        extensions
            grapycal_builtin
            grapycal_torch
            grapycal_ros
            ...

The Grapycal application consists of the backend (written in Python) and the frontend (written in Typescript).

How backend works
-----------------

The backend folder is the python package of Grapycal. When you run `python -m grapycal`, a GrapycalApp (``app.py``) starts and creates two processes, the workspace and the HTTP server.

The workspace (``core/workspace.py``) is the core of Grapycal. It loads the workspace file, creats the tree of SObjects, and starts the websocket server. It runs two threads, the background (main) thread and the communication thread. The background thread runs a syncronous loop with a queue to run tasks generated by nodes. The communication thread runs an event loop to handle websocket communication with the frontend and a timer for periodic tasks.

How frontend works
------------------

The frontend use no framework. It's just a bunch of Typescript classes. The UI is implemented with HTML and CSS (welcome to re-structure them if you know frontend!). 

The frontend folder is a npm package. The entry point, ``app.ts``, creates a websocket connection to the backend and ask for the information about the SObject tree and the topics. It then create everyting on the UI accroding to the information.

How backend and frontend interact
--------------------

To elegantly implement state syncronization between the backend and the frontend, we use `ObjectSync library <https://github.com/eri24816/ObjectSync>`_ to wrap two layers of abstractions on top of websocket: `Topics` and `SObject` s (Syncronized Object).

A `topic` is **a piece of data** that is shared across the backend and the frontend. When either side changes a topic, the change is automatically broadcasted to the other side with websocket so the other side can update the topic accordingly and reflect to the change if necessary.

A `SObject` is **an object** that is shared across the backend and the frontend. Each `SObject` owns a specific set of `attributes`, implemented with `topics`, syncronized between the backend and the frontend.

.. figure:: https://i.imgur.com/8fWPdNC.png
    :height: 250px
    :align: center

    The concept of SObject and topic. `o1` and `o2` are SObjects. `t1` - `t5` are topics. `t1` and `t2` are attributes of `o1`. `t3`, `t4` and `t5` are attributes of `o2`.


ObjectSync's implementation details are not important. We just need to know that
ObjectSync automatically do the following for Grapycal:

#. When a SObject is created/deleted on the backend, a SObject with the same class is automatically created/deleted on the frontend. 
#. When some attributes of SObject on the backend changes, the change is broadcasted to all frontends and the SObject on the frontends are updated accordingly.
#. When the SObject on a frontend is chagned by user, a request of change is sent to the backend. The backend updates the SObject accordingly and broadcast the change to all frontends.

Many class in Grapycal inherits from SObject, such as `Node`, `Edge`, `Port`, etc.. In a workspace, they are organized in a tree structure:

.. code-block:: text

    root
    └───Workspace
        ├───Sidebar
        │   ├───AdditionNode
        │   │   └──...     
        │   ├───EvalNode
        │   │   └──... 
        │   └───PrintNode
        │   │   └──... 
        └───Editor
            ├───AdditionNode
            │   └──... 
            ├───EvalNode
            │   └──... 
            ├───PrintNode
            │   └──... 
            ├───EvalNode
            │   └──... 
            ├───Edge
            └───Edge

The `Sidebar` contains preview of all the nodes that can be added to the editor. The `Editor` contains all the nodes and edges been added to it.

In each node, there can be `ports` and `controls`. For example:

.. code-block:: text

    SomeTypeOfNode
    ├───Port
    ├───Port
    ├───TextControl
    └───ButtonControl

A `port` is a connection point for edges. A `control` is a UI element that allows user to interact with the node. `Ports` and `controls` can be added to a node in the building process of the node, or be added (or removed) dynamically as the node's runtime behavior. For example, the lambda node creates a port each time user adds a new input variable.


Definitions of SObjects are in ``backend/src/grapycal/sobjects`` and ``frontend/src/sobjects``.